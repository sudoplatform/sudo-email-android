enum KeyFormat {
  # PKCS#1 RSA Public Key
  RSA_PUBLIC_KEY
  # X.509 SubjectPublicKeyInfo
  SPKI
}

type PaginatedPublicKey {
  items: [PublicKey!]!
  nextToken: String
}

type PublicKey {
  id: ID!
  keyId: String!
  keyRingId: String!
  algorithm: String!
  keyFormat: KeyFormat
  publicKey: String!
  owner: ID!
  version: Int!
  createdAtEpochMs: Float!
  updatedAtEpochMs: Float!
}

enum EmailMessageState {
  QUEUED
  SENT
  DELIVERED
  UNDELIVERED
  FAILED
  RECEIVED
}

enum EmailMessageDirection {
  INBOUND
  OUTBOUND
}

enum EmailMessageEncryptionStatus {
  ENCRYPTED
  UNENCRYPTED
}

enum UpdateEmailMessagesStatus {
  SUCCESS
  PARTIAL
  FAILED
}

enum SortOrder {
  ASC
  DESC
}

input CreatePublicKeyInput {
  keyId: String!
  keyRingId: String!
  algorithm: String!
  keyFormat: KeyFormat
  publicKey: String!
}

input ProvisionEmailAddressPublicKeyInput {
  keyId: String!
  algorithm: String!
  keyFormat: KeyFormat
  publicKey: String!
}

input ProvisionEmailAddressInput {
  ownershipProofTokens: [String!]!
  emailAddress: String!
  key: ProvisionEmailAddressPublicKeyInput!
  alias: SealedAttributeInput
}

input EmailAddressMetadataUpdateValuesInput {
  alias: SealedAttributeInput
}

input UpdateEmailAddressMetadataInput {
  id: ID!
  values: EmailAddressMetadataUpdateValuesInput!
}

input CheckEmailAddressAvailabilityInput {
  localParts: [String!]!
  domains: [String!]
}

input ListEmailAddressesInput {
  limit: Int
  nextToken: String
}

input ListEmailAddressesForSudoIdInput {
  sudoId: ID!
  limit: Int
  nextToken: String
}

input ListEmailFoldersForEmailAddressIdInput {
  emailAddressId: ID!
  limit: Int
  nextToken: String
}

input ListEmailMessagesInput {
  specifiedDateRange: EmailMessageDateRangeInput
  limit: Int
  sortOrder: SortOrder
  nextToken: String
}

input ListEmailMessagesForEmailAddressIdInput {
  emailAddressId: ID!
  specifiedDateRange: EmailMessageDateRangeInput
  limit: Int
  sortOrder: SortOrder
  nextToken: String
}

input ListEmailMessagesForEmailFolderIdInput {
  folderId: ID!
  specifiedDateRange: EmailMessageDateRangeInput
  limit: Int
  sortOrder: SortOrder
  nextToken: String
}

input LookupEmailAddressesPublicInfoInput {
  emailAddresses: [String!]!
}

input DeprovisionEmailAddressInput {
  emailAddressId: ID!
}

input Rfc822HeaderInput {
  from: String!
  to: [String!]!
  cc: [String!]!
  bcc: [String!]!
  replyTo: [String!]!
  subject: String
  hasAttachments: Boolean
}

input SendEmailMessageInput {
  emailAddressId: ID!
  message: S3EmailObjectInput!
  clientRefId: String
}

input SendEncryptedEmailMessageInput {
  emailAddressId: ID!
  message: S3EmailObjectInput!
  clientRefId: String
  rfc822Header: Rfc822HeaderInput!
}

input DeleteEmailMessagesInput {
  messageIds: [ID!]!
}

input EmailMessageUpdateValuesInput {
  folderId: ID
  seen: Boolean
}

input UpdateEmailMessagesInput {
  messageIds: [ID!]!
  values: EmailMessageUpdateValuesInput!
}

input DeleteEmailMessageInput {
  messageId: ID!
}

input OwnerInput {
  id: String!
  issuer: String!
}

input DateRangeInput {
  startDateEpochMs: Float!
  endDateEpochMs: Float!
}

input EmailMessageDateRangeInput {
  updatedAtEpochMs: DateRangeInput
  sortDateEpochMs: DateRangeInput
}

input S3EmailObjectInput {
  key: String!
  bucket: String!
  region: String!
}

input SealedAttributeInput {
  algorithm: String!
  keyId: String!
  plainTextType: String!
  base64EncodedSealedData: String!
}

enum BlockedAddressHashAlgorithm {
  SHA256
}

input BlockedEmailAddressInput {
  hashedBlockedValue: String!
  hashAlgorithm: BlockedAddressHashAlgorithm!
  sealedValue: SealedAttributeInput!
}

input BlockEmailAddressesInput {
  owner: ID!
  blockedAddresses: [BlockedEmailAddressInput!]!
}

input UnblockEmailAddressesInput {
  owner: ID!
  unblockedAddresses: [String!]!
}

input GetEmailAddressBlocklistInput {
  owner: ID!
}

type EmailConfigurationData {
  deleteEmailMessagesLimit: Int!
  updateEmailMessagesLimit: Int!
  emailMessageMaxInboundMessageSize: Int!
  emailMessageMaxOutboundMessageSize: Int!
}

type Owner {
  id: String!
  issuer: String!
}

type EmailAddress {
  id: ID!
  owner: ID!
  owners: [Owner!]!
  identityId: ID!
  keyRingId: ID!
  keyIds: [String!]!
  version: Int!
  createdAtEpochMs: Float!
  updatedAtEpochMs: Float!
  lastReceivedAtEpochMs: Float
  emailAddress: String!
  size: Float!
  alias: SealedAttribute
  folders: [EmailFolder!]!
}

type EmailFolder {
  id: ID!
  owner: ID!
  owners: [Owner!]!
  emailAddressId: ID!
  folderName: String!
  size: Float!
  unseenCount: Float!
  ttl: Float
  version: Int!
  createdAtEpochMs: Float!
  updatedAtEpochMs: Float!
}

type SealedEmailMessage {
  id: ID!
  owner: ID!
  owners: [Owner!]!
  emailAddressId: ID!
  version: Int!
  createdAtEpochMs: Float!
  updatedAtEpochMs: Float!
  sortDateEpochMs: Float!
  folderId: ID!
  previousFolderId: ID
  direction: EmailMessageDirection!
  seen: Boolean!
  state: EmailMessageState!
  clientRefId: String
  rfc822Header: SealedAttribute!
  size: Float!
  encryptionStatus: EmailMessageEncryptionStatus
}

type UpdateEmailMessagesResult {
  status: UpdateEmailMessagesStatus!
  failedMessageIds: [ID!]
  successMessageIds: [ID!]
}

# Array of email domains.
type SupportedDomains {
  domains: [String!]!
}

type AvailableAddresses {
  addresses: [String!]!
}

type EmailAddressConnection {
  items: [EmailAddress!]!
  nextToken: String
}

type EmailFolderConnection {
  items: [EmailFolder!]!
  nextToken: String
}

type EmailMessageConnection {
  items: [SealedEmailMessage!]!
  nextToken: String
}

type EmailAddressPublicInfo {
  emailAddress: String!
  keyId: String!
  publicKey: String!
}

type LookupEmailAddressesPublicInfoResponse {
  items: [EmailAddressPublicInfo!]!
}

type BlockedEmailAddress {
  owner: ID!
  owners: [Owner!]!
  version: Int!
  createdAtEpochMs: Float!
  updatedAtEpochMs: Float!
  # Hashed value of the address to block
  hashedBlockedValue: String!
  # Algorithm used for hashing
  hashAlgorithm: BlockedAddressHashAlgorithm!
  # Sealed value of address to block
  sealedValue: SealedAttribute!
}

enum BlockEmailAddressesBulkUpdateStatus {
  SUCCESS
  PARTIAL
  FAILED
}

type BlockEmailAddressesBulkUpdateResult {
  status: BlockEmailAddressesBulkUpdateStatus!
  failedAddresses: [String!]
  successAddresses: [String!]
}

type GetEmailAddressBlocklistResponse {
  blockedAddresses: [BlockedEmailAddress!]!
}

type Query {
  getEmailConfig: EmailConfigurationData!

  getEmailDomains: SupportedDomains!

  checkEmailAddressAvailability(
    input: CheckEmailAddressAvailabilityInput!
  ): AvailableAddresses!

  getEmailAddress(id: String!): EmailAddress

  listEmailAddresses(input: ListEmailAddressesInput!): EmailAddressConnection!

  listEmailAddressesForSudoId(
    input: ListEmailAddressesForSudoIdInput!
  ): EmailAddressConnection!

  listEmailFoldersForEmailAddressId(
    input: ListEmailFoldersForEmailAddressIdInput!
  ): EmailFolderConnection!

  getEmailMessage(id: ID!): SealedEmailMessage

  listEmailMessages(
    input: ListEmailMessagesInput!
  ): EmailMessageConnection!

  listEmailMessagesForEmailAddressId(
    input: ListEmailMessagesForEmailAddressIdInput!
  ): EmailMessageConnection!

  listEmailMessagesForEmailFolderId(
    input: ListEmailMessagesForEmailFolderIdInput!
  ): EmailMessageConnection!

  getPublicKeyForEmail(keyId: String!): PublicKey

  getPublicKeysForEmail(limit: Int, nextToken: String): PaginatedPublicKey!

  getKeyRingForEmail(
    keyRingId: String!
    limit: Int
    nextToken: String
  ): PaginatedPublicKey!

  lookupEmailAddressesPublicInfo(
    input: LookupEmailAddressesPublicInfoInput!
  ): LookupEmailAddressesPublicInfoResponse!

  getEmailAddressBlocklist(
    input: GetEmailAddressBlocklistInput!
  ): GetEmailAddressBlocklistResponse!
}

type Mutation {
  createPublicKeyForEmail(input: CreatePublicKeyInput!): PublicKey!

  provisionEmailAddress(input: ProvisionEmailAddressInput!): EmailAddress!

  deprovisionEmailAddress(input: DeprovisionEmailAddressInput!): EmailAddress!

  sendEmailMessage(input: SendEmailMessageInput!): ID!

  sendEncryptedEmailMessage(input: SendEncryptedEmailMessageInput!): ID!

  deleteEmailMessages(input: DeleteEmailMessagesInput!): [ID!]!

  updateEmailMessages(
    input: UpdateEmailMessagesInput!
  ): UpdateEmailMessagesResult!

  deleteEmailMessage(input: DeleteEmailMessageInput!): ID!

  updateEmailAddressMetadata(input: UpdateEmailAddressMetadataInput!): ID!

  blockEmailAddresses(input: BlockEmailAddressesInput!): BlockEmailAddressesBulkUpdateResult!

  unblockEmailAddresses(input: UnblockEmailAddressesInput!): BlockEmailAddressesBulkUpdateResult!
}

type Subscription {
  onEmailAddressCreated(owner: ID!): EmailAddress

  onEmailMessageCreated(
    owner: String!
    direction: EmailMessageDirection
  ): SealedEmailMessage

  onEmailMessageDeleted(owner: ID!, id: ID): SealedEmailMessage
}
